<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🏁 Damas - GameHub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
        
        * {
            font-family: 'Poppins', sans-serif;
        }
        
        .board-square {
            aspect-ratio: 1;
            transition: all 0.2s ease;
        }
        
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        
        .piece:hover {
            transform: scale(1.1);
        }
        
        .red-piece {
            background: linear-gradient(145deg, #dc2626, #b91c1c);
            border-color: #7f1d1d;
            box-shadow: 0 4px 8px rgba(220, 38, 38, 0.4);
        }
        
        .black-piece {
            background: linear-gradient(145deg, #374151, #1f2937);
            border-color: #111827;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        .king {
            font-size: 16px;
            color: #fbbf24;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        
        .selected {
            ring: 4px;
            ring-color: #3b82f6;
            transform: scale(1.1);
        }
        
        .valid-move {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
        }
        
        .capture-move {
            background: rgba(239, 68, 68, 0.3);
            border: 2px solid #ef4444;
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #0f766e 0%, #065f46 100%);
        }
    </style>
</head>
<body class="gradient-bg min-h-screen p-4">
    <!-- Header Banner Ad -->
    <div class="fixed top-0 left-0 right-0 bg-black/80 backdrop-blur-sm z-10 py-2">
        <div class="max-w-4xl mx-auto text-center">
            <div class="bg-gray-200 text-gray-500 py-2 rounded text-sm">
                📢 Espaço Publicitário (AdSense)
            </div>
        </div>
    </div>

    <div class="flex flex-col items-center justify-center min-h-screen mt-16">
        <!-- Header do Jogo -->
        <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-4 w-full max-w-2xl">
            <div class="text-center mb-4">
                <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">
                    🏁 Damas Inteligentes
                </h1>
                <p class="text-white/80">Desafie a IA em 3 níveis de dificuldade!</p>
                
                <!-- Voltar para menu -->
                <div class="mt-4">
                    <a href="../index.html" class="text-cyan-300 hover:text-cyan-100 font-semibold">
                        ← Voltar ao Menu
                    </a>
                </div>
            </div>

            <!-- Controles -->
            <div class="flex flex-col md:flex-row gap-4 mb-4">
                <!-- Modo de Jogo -->
                <button id="toggle-mode" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg font-bold transition-colors flex-1">
                    🤖 vs COMPUTADOR
                </button>
                
                <!-- Dificuldade -->
                <button id="difficulty-btn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg font-bold transition-colors flex-1">
                    😊 FÁCIL
                </button>
                
                <!-- Regras -->
                <button id="rules-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-bold transition-colors flex-1">
                    📖 REGRAS
                </button>
            </div>

            <!-- Status -->
            <div class="flex justify-between items-center bg-black/30 rounded-lg p-3 mb-4">
                <div class="text-white">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-600 rounded-full"></div>
                        <span>Você: <span id="red-count">12</span></span>
                    </div>
                </div>
                <div id="game-status" class="text-lg font-bold text-white">
                    Sua vez!
                </div>
                <div class="text-white">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-gray-800 rounded-full"></div>
                        <span>IA: <span id="black-count">12</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabuleiro -->
        <div class="bg-yellow-800 p-4 rounded-2xl shadow-2xl">
            <div id="board" class="grid grid-cols-8 gap-1">
                <!-- Casas do tabuleiro serão criadas via JavaScript -->
            </div>
        </div>

        <!-- Novo Jogo -->
        <div class="mt-4">
            <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white px-8 py-3 rounded-lg font-bold transition-colors">
                🔄 Novo Jogo
            </button>
        </div>

        <!-- Banner Bottom -->
        <div class="mt-6 text-center">
            <div class="bg-gray-200 text-gray-500 py-8 rounded max-w-md">
                📢 Espaço Publicitário (AdSense)
            </div>
        </div>
    </div>

    <!-- Modal de Regras -->
    <div id="rules-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg p-6 max-w-md w-full max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">📖 Como Jogar Damas</h2>
                <button id="close-rules" class="text-gray-600 hover:text-gray-800 text-xl font-bold">✕</button>
            </div>
            <div class="space-y-3 text-gray-700">
                <p><strong>🎯 Objetivo:</strong> Capture todas as peças do adversário ou bloqueie seus movimentos.</p>
                <p><strong>📏 Movimento:</strong> Peças normais movem 1 casa na diagonal para frente.</p>
                <p><strong>👑 Damas:</strong> Podem mover múltiplas casas em qualquer diagonal.</p>
                <p><strong>⚔️ Captura:</strong> Pule sobre peça inimiga. Capturas são obrigatórias!</p>
                <p><strong>🔄 Capturas múltiplas:</strong> Continue capturando com a mesma peça se possível.</p>
                <p><strong>👑 Promoção:</strong> Peça vira dama ao chegar na última linha adversária.</p>
                <p><strong>🏆 Vitória:</strong> Elimine todas as peças inimigas ou as bloqueie.</p>
            </div>
            <button id="close-rules-btn" class="w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg">
                ✅ Entendi!
            </button>
        </div>
    </div>

    <!-- Modal de Game Over -->
    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg p-6 max-w-md w-full text-center">
            <div id="game-result" class="text-2xl font-bold mb-4"></div>
            <div class="mb-4">
                <div class="bg-gray-200 text-gray-500 rounded flex items-center justify-center" style="width:300px; height:250px; margin:0 auto;">
                    📢 Anúncio
                </div>
            </div>
            <div class="flex gap-2">
                <button id="play-again" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition">
                    🔄 Jogar Novamente
                </button>
                <button id="back-menu" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition">
                    🏠 Menu
                </button>
            </div>
        </div>
    </div>

    <script>
        class CheckersGame {
            constructor() {
                this.BOARD_SIZE = 8;
                this.board = [];
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameOver = false;
                this.winner = null;
                this.redPieces = 12;
                this.blackPieces = 12;
                this.mustCapture = false;
                this.vsComputer = true;
                this.difficulty = 'easy';
                this.isComputerThinking = false;
                
                this.init();
            }
            
            init() {
                this.initializeBoard();
                this.createBoardHTML();
                this.attachEventListeners();
                this.updateDisplay();
            }
            
            initializeBoard() {
                this.board = Array(this.BOARD_SIZE).fill(null).map(() => Array(this.BOARD_SIZE).fill(null));
                
                // Peças pretas (topo) - IA
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < this.BOARD_SIZE; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { color: 'black', isKing: false };
                        }
                    }
                }
                
                // Peças vermelhas (fundo) - Jogador
                for (let row = 5; row < this.BOARD_SIZE; row++) {
                    for (let col = 0; col < this.BOARD_SIZE; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { color: 'red', isKing: false };
                        }
                    }
                }
            }
            
            createBoardHTML() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < this.BOARD_SIZE; row++) {
                    for (let col = 0; col < this.BOARD_SIZE; col++) {
                        const square = document.createElement('div');
                        square.classList.add('board-square', 'w-12', 'h-12', 'md:w-16', 'md:h-16', 'flex', 'items-center', 'justify-center', 'cursor-pointer');
                        
                        if ((row + col) % 2 === 0) {
                            square.classList.add('bg-yellow-200');
                        } else {
                            square.classList.add('bg-yellow-700');
                        }
                        
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', () => this.handleSquareClick(row, col));
                        
                        const piece = this.board[row][col];
                        if (piece) {
                            square.appendChild(this.createPieceElement(piece));
                        }
                        
                        boardElement.appendChild(square);
                    }
                }
            }
            
            createPieceElement(piece) {
                const pieceElement = document.createElement('div');
                pieceElement.classList.add('piece');
                
                if (piece.color === 'red') {
                    pieceElement.classList.add('red-piece');
                } else {
                    pieceElement.classList.add('black-piece');
                }
                
                if (piece.isKing) {
                    pieceElement.innerHTML = '<span class="king">♔</span>';
                    pieceElement.classList.add('king');
                }
                
                return pieceElement;
            }
            
            handleSquareClick(row, col) {
                if (this.gameOver || this.isComputerThinking) return;
                if (this.vsComputer && this.currentPlayer === 'black') return;
                
                const piece = this.board[row][col];
                
                if (this.selectedPiece) {
                    const { row: selectedRow, col: selectedCol } = this.selectedPiece;
                    const validMove = this.validMoves.find(move => move.row === row && move.col === col);
                    
                    if (validMove) {
                        this.makeMove(selectedRow, selectedCol, row, col, validMove);
                    } else if (piece && piece.color === this.currentPlayer) {
                        this.selectPiece(row, col);
                    } else {
                        this.deselectPiece();
                    }
                } else if (piece && piece.color === this.currentPlayer) {
                    this.selectPiece(row, col);
                }
            }
            
            selectPiece(row, col) {
                // Verificar se há capturas obrigatórias no tabuleiro
                const allPlayerMoves = this.getAllPossibleMoves(this.currentPlayer);
                const mandatoryCaptures = allPlayerMoves.filter(m => m.moveData.type === 'capture');
                
                // Se há capturas obrigatórias, só permitir selecionar peças que podem capturar
                if (mandatoryCaptures.length > 0) {
                    const pieceCanCapture = mandatoryCaptures.some(m => 
                        m.fromRow === row && m.fromCol === col
                    );
                    
                    if (!pieceCanCapture) {
                        // Mostrar mensagem que deve capturar
                        document.getElementById('game-status').textContent = 'Captura obrigatória!';
                        setTimeout(() => {
                            const status = this.currentPlayer === 'red' ? 'Sua vez!' : 'Vez da IA';
                            document.getElementById('game-status').textContent = status;
                        }, 1500);
                        return;
                    }
                }
                
                this.selectedPiece = { row, col };
                this.validMoves = this.getPossibleMoves(row, col);
                this.updateBoardDisplay();
            }
            
            deselectPiece() {
                this.selectedPiece = null;
                this.validMoves = [];
                this.updateBoardDisplay();
            }
            
            getPossibleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const moves = [];
                
                if (piece.isKing) {
                    // DAMAS: Movimentos e capturas em múltiplas casas
                    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    
                    directions.forEach(([deltaRow, deltaCol]) => {
                        // Procurar por capturas em todas as distâncias
                        for (let distance = 1; distance < Math.max(this.BOARD_SIZE, this.BOARD_SIZE); distance++) {
                            const jumpRow = row + (deltaRow * distance);
                            const jumpCol = col + (deltaCol * distance);
                            
                            if (!this.isValidPosition(jumpRow, jumpCol)) break;
                            
                            const jumpPiece = this.board[jumpRow][jumpCol];
                            
                            if (jumpPiece) {
                                if (jumpPiece.color !== piece.color) {
                                    // Encontrou peça inimiga, procurar casa de pouso
                                    for (let landDistance = distance + 1; landDistance < Math.max(this.BOARD_SIZE, this.BOARD_SIZE); landDistance++) {
                                        const landRow = row + (deltaRow * landDistance);
                                        const landCol = col + (deltaCol * landDistance);
                                        
                                        if (!this.isValidPosition(landRow, landCol)) break;
                                        
                                        if (!this.board[landRow][landCol]) {
                                            moves.push({
                                                row: landRow,
                                                col: landCol,
                                                type: 'capture',
                                                capturedRow: jumpRow,
                                                capturedCol: jumpCol
                                            });
                                        } else {
                                            break; // Bloqueado por outra peça
                                        }
                                    }
                                }
                                break; // Parar nesta direção (peça encontrada)
                            }
                        }
                        
                        // Movimentos normais da dama (se não há capturas)
                        for (let distance = 1; distance < Math.max(this.BOARD_SIZE, this.BOARD_SIZE); distance++) {
                            const newRow = row + (deltaRow * distance);
                            const newCol = col + (deltaCol * distance);
                            
                            if (!this.isValidPosition(newRow, newCol)) break;
                            
                            if (!this.board[newRow][newCol]) {
                                moves.push({ row: newRow, col: newCol, type: 'move' });
                            } else {
                                break; // Bloqueado
                            }
                        }
                    });
                } else {
                    // PEÇAS NORMAIS: Capturas em todas as direções, movimentos só para frente
                    const captureDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    captureDirections.forEach(([deltaRow, deltaCol]) => {
                        const jumpRow = row + deltaRow;
                        const jumpCol = col + deltaCol;
                        const landRow = row + (deltaRow * 2);
                        const landCol = col + (deltaCol * 2);
                        
                        if (this.isValidPosition(jumpRow, jumpCol) && 
                            this.isValidPosition(landRow, landCol) &&
                            this.board[jumpRow][jumpCol] && 
                            this.board[jumpRow][jumpCol].color !== piece.color &&
                            !this.board[landRow][landCol]) {
                            moves.push({ 
                                row: landRow, 
                                col: landCol, 
                                type: 'capture',
                                capturedRow: jumpRow,
                                capturedCol: jumpCol
                            });
                        }
                    });
                    
                    // Movimentos normais (apenas para frente se não há capturas)
                    const directions = piece.color === 'red' 
                        ? [[-1, -1], [-1, 1]]  // Vermelho para cima
                        : [[1, -1], [1, 1]];   // Preto para baixo
                    
                    directions.forEach(([deltaRow, deltaCol]) => {
                        const newRow = row + deltaRow;
                        const newCol = col + deltaCol;
                        
                        if (this.isValidPosition(newRow, newCol) && !this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, type: 'move' });
                        }
                    });
                }
                
                // Se há capturas disponíveis, retornar APENAS capturas
                const captures = moves.filter(move => move.type === 'capture');
                if (captures.length > 0) {
                    return captures;
                }
                
                return moves.filter(move => move.type === 'move');
            }
            
            isValidPosition(row, col) {
                return row >= 0 && row < this.BOARD_SIZE && col >= 0 && col < this.BOARD_SIZE;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol, moveData) {
                console.log(`Movimento: (${fromRow},${fromCol}) → (${toRow},${toCol})`);
                
                // Verificações de segurança
                if (!this.isValidPosition(fromRow, fromCol) || !this.isValidPosition(toRow, toCol)) {
                    console.error('Posições inválidas no movimento');
                    return;
                }
                
                const piece = this.board[fromRow][fromCol];
                if (!piece) {
                    console.error('Nenhuma peça na posição de origem');
                    return;
                }
                
                if (this.board[toRow][toCol]) {
                    console.error('Posição de destino ocupada');
                    return;
                }
                
                // Executar movimento
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                console.log('Peça movida com sucesso');
                
                let continueCapturing = false;
                
                if (moveData && moveData.type === 'capture') {
                    console.log('Processando captura...');
                    this.board[moveData.capturedRow][moveData.capturedCol] = null;
                    if (piece.color === 'red') {
                        this.blackPieces--;
                    } else {
                        this.redPieces--;
                    }
                    
                    // Verificar se há mais capturas possíveis com a mesma peça
                    const additionalCaptures = this.getPossibleMoves(toRow, toCol)
                        .filter(move => move.type === 'capture');
                    
                    if (additionalCaptures.length > 0) {
                        // Continuar capturando com a mesma peça
                        continueCapturing = true;
                        this.selectedPiece = { row: toRow, col: toCol };
                        this.validMoves = additionalCaptures;
                        this.updateBoardDisplay();
                        console.log('Capturas múltiplas disponíveis');
                        return; // Não trocar de jogador ainda
                    }
                }
                
                // Promover a dama
                if (!piece.isKing) {
                    if ((piece.color === 'red' && toRow === 0) || 
                        (piece.color === 'black' && toRow === 7)) {
                        piece.isKing = true;
                        console.log('Peça promovida a dama!');
                    }
                }
                
                this.deselectPiece();
                this.checkGameOver();
                
                if (!this.gameOver && !continueCapturing) {
                    this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
                    console.log('Mudando jogador para:', this.currentPlayer);
                    this.updateDisplay();
                    
                    if (this.vsComputer && this.currentPlayer === 'black') {
                        // Pequeno delay para ver o movimento
                        setTimeout(() => {
                            if (!this.gameOver && this.currentPlayer === 'black') {
                                this.makeComputerMove();
                            }
                        }, 300);
                    }
                }
            }
            
            makeComputerMove() {
                if (this.isComputerThinking || this.gameOver) return;
                
                this.isComputerThinking = true;
                document.getElementById('game-status').textContent = 'IA pensando...';
                
                // Tempo de "pensamento" baseado na dificuldade
                const thinkingTime = {
                    'easy': 400,
                    'medium': 900,
                    'hard': 2000  // IA Expert pensa mais tempo
                };
                
                setTimeout(() => {
                    try {
                        console.log('IA começando movimento...');
                        const allMoves = this.getAllPossibleMoves('black');
                        console.log('Movimentos encontrados:', allMoves.length);
                        
                        if (allMoves.length > 0) {
                            // Fazer movimento simples e direto
                            const selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                            console.log('Movimento selecionado:', selectedMove);
                            
                            // Verificar se o movimento é válido
                            if (this.isValidMove(selectedMove)) {
                                console.log('Executando movimento...');
                                this.makeMove(
                                    selectedMove.fromRow,
                                    selectedMove.fromCol,
                                    selectedMove.moveData.row,
                                    selectedMove.moveData.col,
                                    selectedMove.moveData
                                );
                            } else {
                                console.log('Movimento inválido, tentando outro...');
                                // Tentar com o primeiro movimento válido
                                for (let move of allMoves) {
                                    if (this.isValidMove(move)) {
                                        this.makeMove(
                                            move.fromRow,
                                            move.fromCol,
                                            move.moveData.row,
                                            move.moveData.col,
                                            move.moveData
                                        );
                                        break;
                                    }
                                }
                            }
                        } else {
                            console.log('IA sem movimentos - jogador venceu');
                            this.endGame('red');
                        }
                    } catch (error) {
                        console.error('Erro na IA:', error);
                        // Em caso de erro, tentar movimento mais simples
                        this.makeSimpleAIMove();
                    }
                    
                    this.isComputerThinking = false;
                    console.log('IA terminou movimento');
                }, thinkingTime[this.difficulty]);
            }
            
            isValidMove(move) {
                if (!move || !move.moveData) return false;
                
                const { fromRow, fromCol, moveData } = move;
                const { row: toRow, col: toCol } = moveData;
                
                // Verificar se posições são válidas
                if (!this.isValidPosition(fromRow, fromCol) || !this.isValidPosition(toRow, toCol)) {
                    return false;
                }
                
                // Verificar se há peça na origem
                if (!this.board[fromRow][fromCol] || this.board[fromRow][fromCol].color !== 'black') {
                    return false;
                }
                
                // Verificar se destino está livre
                if (this.board[toRow][toCol]) {
                    return false;
                }
                
                return true;
            }
            
            makeSimpleAIMove() {
                console.log('Tentando movimento simples...');
                // Encontrar qualquer peça preta que pode se mover
                for (let row = 0; row < this.BOARD_SIZE; row++) {
                    for (let col = 0; col < this.BOARD_SIZE; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === 'black') {
                            const simpleMoves = this.getSimpleMoves(row, col);
                            if (simpleMoves.length > 0) {
                                const move = simpleMoves[0];
                                console.log('Movimento simples encontrado:', move);
                                this.makeMove(row, col, move.row, move.col, move);
                                return;
                            }
                        }
                    }
                }
                
                // Se chegou aqui, IA realmente não tem movimentos
                console.log('IA realmente sem movimentos');
                this.endGame('red');
            }
            
            getSimpleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece || piece.color !== 'black') return [];
                
                const moves = [];
                const directions = piece.isKing 
                    ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
                    : [[1, -1], [1, 1]]; // Peças pretas movem para baixo
                
                directions.forEach(([deltaRow, deltaCol]) => {
                    const newRow = row + deltaRow;
                    const newCol = col + deltaCol;
                    
                    if (this.isValidPosition(newRow, newCol) && !this.board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, type: 'move' });
                    }
                });
                
                return moves;
            }
            
            chooseBestCapture(captures) {
                switch(this.difficulty) {
                    case 'easy':
                        // Escolha aleatória
                        return captures[Math.floor(Math.random() * captures.length)];
                        
                    case 'medium':
                        // Priorizar capturas que levam a mais capturas
                        return this.getBestCaptureBasic(captures);
                        
                    case 'hard':
                        // Análise profunda de capturas
                        return this.getBestCaptureExpert(captures);
                        
                    default:
                        return captures[Math.floor(Math.random() * captures.length)];
                }
            }
            
            getBestCaptureBasic(captures) {
                let bestCaptures = [];
                let maxValue = -1;
                
                captures.forEach(capture => {
                    let value = 10; // Valor base da captura
                    
                    // Capturar peças mais avançadas vale mais
                    value += (7 - capture.moveData.capturedRow) * 3;
                    
                    // Verificar se leva a mais capturas
                    const additionalCaptures = this.simulateAdditionalCaptures(capture);
                    value += additionalCaptures * 15;
                    
                    if (value > maxValue) {
                        maxValue = value;
                        bestCaptures = [capture];
                    } else if (value === maxValue) {
                        bestCaptures.push(capture);
                    }
                });
                
                return bestCaptures[Math.floor(Math.random() * bestCaptures.length)];
            }
            
            getBestCaptureExpert(captures) {
                let scoredCaptures = captures.map(capture => ({
                    capture,
                    score: this.evaluateCaptureExpert(capture)
                }));
                
                // Ordenar por pontuação
                scoredCaptures.sort((a, b) => b.score - a.score);
                
                // Escolher a melhor captura (IA Expert não erra!)
                return scoredCaptures[0].capture;
            }
            
            evaluateCaptureExpert(capture) {
                let score = 20; // Valor base da captura
                
                // 1. Valor da peça capturada
                const capturedRow = capture.moveData.capturedRow;
                const capturedCol = capture.moveData.capturedCol;
                const capturedPiece = this.board[capturedRow][capturedCol];
                
                if (capturedPiece.isKing) {
                    score += 50; // Capturar dama é muito valioso!
                } else {
                    // Peças mais avançadas valem mais
                    score += (7 - capturedRow) * 5;
                }
                
                // 2. Capturas múltiplas
                const additionalCaptures = this.simulateAdditionalCaptures(capture);
                score += additionalCaptures * 25;
                
                // 3. Posição final após captura
                if (this.isPositionSafe(capture.moveData.row, capture.moveData.col, 'black')) {
                    score += 15;
                } else {
                    score -= 10; // Penalizar se ficar exposto
                }
                
                // 4. Promoção após captura
                if (capture.moveData.row === 7) {
                    score += 40; // Capturar e virar dama!
                }
                
                // 5. Controle territorial após captura
                const centerDistance = Math.abs(capture.moveData.col - 3.5);
                score += (4 - centerDistance) * 3;
                
                return score;
            }
            
            chooseBestMove(allMoves) {
                switch(this.difficulty) {
                    case 'easy':
                        // 70% movimentos aleatórios
                        return allMoves[Math.floor(Math.random() * allMoves.length)];
                        
                    case 'medium':
                        // Estratégia moderada: priorizar avanço
                        return this.getMediumMove(allMoves);
                        
                    case 'hard':
                        // IA EXPERT: análise profunda e estratégica
                        return this.getExpertMove(allMoves);
                        
                    default:
                        return allMoves[Math.floor(Math.random() * allMoves.length)];
                }
            }
            
            getMediumMove(allMoves) {
                let scoredMoves = allMoves.map(move => ({
                    move,
                    score: this.evaluateMoveBasic(move)
                }));
                
                // Ordenar por pontuação e escolher entre os 3 melhores
                scoredMoves.sort((a, b) => b.score - a.score);
                const topMoves = scoredMoves.slice(0, Math.min(3, scoredMoves.length));
                
                return topMoves[Math.floor(Math.random() * topMoves.length)].move;
            }
            
            getExpertMove(allMoves) {
                let scoredMoves = allMoves.map(move => ({
                    move,
                    score: this.evaluateMoveExpert(move)
                }));
                
                // Ordenar por pontuação e escolher o melhor movimento
                scoredMoves.sort((a, b) => b.score - a.score);
                
                // IA Expert escolhe sempre um dos 2 melhores movimentos
                const bestMoves = scoredMoves.slice(0, Math.min(2, scoredMoves.length));
                return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
            }
            
            evaluateMoveBasic(move) {
                let score = 0;
                const piece = this.board[move.fromRow][move.fromCol];
                
                // Avanço (mais importante)
                if (move.moveData.row > move.fromRow) {
                    score += 20;
                    
                    // Muito perto de virar dama
                    if (move.moveData.row >= 6) {
                        score += 30;
                    }
                }
                
                // Controle do centro
                const centerDistance = Math.abs(move.moveData.col - 3.5);
                score += (4 - centerDistance) * 5;
                
                // Evitar bordas laterais (vulneráveis)
                if (move.moveData.col === 0 || move.moveData.col === 7) {
                    score -= 10;
                }
                
                return score;
            }
            
            evaluateMoveExpert(move) {
                let score = 0;
                const piece = this.board[move.fromRow][move.fromCol];
                
                // 1. PROMOÇÃO A DAMA (prioridade máxima)
                if (!piece.isKing && move.moveData.row === 7) {
                    score += 100; // Vencer vale muito!
                } else if (!piece.isKing && move.moveData.row >= 6) {
                    score += 50; // Muito perto de dama
                } else if (!piece.isKing && move.moveData.row >= 5) {
                    score += 25; // Avanço significativo
                }
                
                // 2. CONTROLE TERRITORIAL AVANÇADO
                score += this.evaluateTerritorialControl(move);
                
                // 3. SEGURANÇA DA PEÇA
                score += this.evaluateSafety(move);
                
                // 4. PRESSÃO SOBRE O ADVERSÁRIO
                score += this.evaluatePressure(move);
                
                // 5. FORMAÇÃO E ESTRUTURA
                score += this.evaluateFormation(move);
                
                // 6. MOBILIDADE FUTURA
                score += this.evaluateMobility(move);
                
                return score;
            }
            
            evaluateTerritorialControl(move) {
                let score = 0;
                
                // Centro é muito valioso
                const centerDistance = Math.abs(move.moveData.col - 3.5) + Math.abs(move.moveData.row - 3.5);
                score += (8 - centerDistance) * 4;
                
                // Controlar as diagonais principais
                if ((move.moveData.row + move.moveData.col) % 2 === 1) {
                    score += 10;
                }
                
                // Avançar é sempre bom
                const advancement = move.moveData.row - move.fromRow;
                score += advancement * 15;
                
                return score;
            }
            
            evaluateSafety(move) {
                let score = 0;
                
                // Verificar se a nova posição é segura
                if (this.isPositionSafe(move.moveData.row, move.moveData.col, 'black')) {
                    score += 20;
                } else {
                    score -= 30; // Penalizar posições perigosas
                }
                
                // Posições nas bordas laterais são mais seguras
                if (move.moveData.col === 0 || move.moveData.col === 7) {
                    score += 15;
                }
                
                // Evitar ficar isolado
                if (this.countNearbyAllies(move.moveData.row, move.moveData.col, 'black') >= 1) {
                    score += 10;
                } else {
                    score -= 5;
                }
                
                return score;
            }
            
            evaluatePressure(move) {
                let score = 0;
                
                // Quantas peças inimigas esta posição pode atacar no futuro?
                const threatenedEnemies = this.countThreatenedEnemies(move.moveData.row, move.moveData.col, 'black');
                score += threatenedEnemies * 8;
                
                // Forçar o oponente a se defender
                if (this.createsThreat(move)) {
                    score += 12;
                }
                
                return score;
            }
            
            evaluateFormation(move) {
                let score = 0;
                
                // Manter peças conectadas (não muito espalhadas)
                const allyCount = this.countNearbyAllies(move.moveData.row, move.moveData.col, 'black');
                if (allyCount === 1 || allyCount === 2) {
                    score += 8; // Formação ideal
                } else if (allyCount === 0) {
                    score -= 5; // Evitar isolamento
                }
                
                // Formar "chains" ofensivas
                if (this.formsChain(move)) {
                    score += 15;
                }
                
                return score;
            }
            
            evaluateMobility(move) {
                let score = 0;
                
                // Contar quantos movimentos futuros terá
                const futureMoves = this.countFutureMoves(move);
                score += futureMoves * 3;
                
                // Damas têm mobilidade muito superior
                const piece = this.board[move.fromRow][move.fromCol];
                if (piece.isKing) {
                    score += 20; // Damas são muito valiosas
                }
                
                return score;
            }
            
            // Funções auxiliares para IA Expert
            countNearbyAllies(row, col, color) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const newRow = row + i;
                        const newCol = col + j;
                        if (this.isValidPosition(newRow, newCol) && 
                            this.board[newRow][newCol] && 
                            this.board[newRow][newCol].color === color) {
                            count++;
                        }
                    }
                }
                return count;
            }
            
            countThreatenedEnemies(row, col, color) {
                let count = 0;
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                
                directions.forEach(([deltaRow, deltaCol]) => {
                    const enemyRow = row + deltaRow;
                    const enemyCol = col + deltaCol;
                    const jumpRow = row + (deltaRow * 2);
                    const jumpCol = col + (deltaCol * 2);
                    
                    if (this.isValidPosition(enemyRow, enemyCol) && 
                        this.isValidPosition(jumpRow, jumpCol) &&
                        this.board[enemyRow][enemyCol] && 
                        this.board[enemyRow][enemyCol].color !== color &&
                        !this.board[jumpRow][jumpCol]) {
                        count++;
                    }
                });
                
                return count;
            }
            
            createsThreat(move) {
                return this.countThreatenedEnemies(move.moveData.row, move.moveData.col, 'black') > 0;
            }
            
            formsChain(move) {
                // Verifica se forma uma sequência diagonal com outras peças
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                
                for (let [deltaRow, deltaCol] of directions) {
                    const ally1Row = move.moveData.row + deltaRow;
                    const ally1Col = move.moveData.col + deltaCol;
                    const ally2Row = move.moveData.row - deltaRow;
                    const ally2Col = move.moveData.col - deltaCol;
                    
                    if (this.isValidPosition(ally1Row, ally1Col) && 
                        this.isValidPosition(ally2Row, ally2Col) &&
                        this.board[ally1Row][ally1Col] && 
                        this.board[ally1Row][ally1Col].color === 'black' &&
                        this.board[ally2Row][ally2Col] && 
                        this.board[ally2Row][ally2Col].color === 'black') {
                        return true;
                    }
                }
                
                return false;
            }
            
            countFutureMoves(move) {
                // Simular quantos movimentos a peça terá na nova posição
                const piece = this.board[move.fromRow][move.fromCol];
                let count = 0;
                
                const directions = piece.isKing 
                    ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
                    : [[1, -1], [1, 1]]; // Peças normais só para frente
                
                directions.forEach(([deltaRow, deltaCol]) => {
                    const newRow = move.moveData.row + deltaRow;
                    const newCol = move.moveData.col + deltaCol;
                    
                    if (this.isValidPosition(newRow, newCol) && !this.board[newRow][newCol]) {
                        count++;
                    }
                });
                
                return count;
            }
            
            getStrategicMove(allMoves) {
                // Estratégias básicas:
                // 1. Avançar peças para virar dama
                // 2. Proteger peças importantes
                // 3. Controlar centro
                
                let bestMoves = [];
                let bestScore = -999;
                
                allMoves.forEach(move => {
                    let score = 0;
                    
                    // Pontos por avançar (especialmente perto de virar dama)
                    if (move.moveData.row < 2) {
                        score += 15; // Muito perto de virar dama
                    } else if (move.moveData.row < 4) {
                        score += 8; // Avançando
                    }
                    
                    // Pontos por controlar centro
                    const centerDistance = Math.abs(move.moveData.col - 3.5);
                    score += (4 - centerDistance) * 2;
                    
                    // Pontos por posições seguras (próximo às bordas)
                    if (move.moveData.col === 0 || move.moveData.col === 7) {
                        score += 5;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                });
                
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }
            
            getBestStrategicMove(allMoves) {
                // IA Difícil - análise mais profunda
                let bestMoves = [];
                let bestScore = -999;
                
                allMoves.forEach(move => {
                    let score = this.evaluatePosition(move);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                });
                
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }
            
            evaluatePosition(move) {
                let score = 0;
                
                // Análise avançada da posição
                const piece = this.board[move.fromRow][move.fromCol];
                
                // Valor da promoção
                if (!piece.isKing && move.moveData.row === 0) {
                    score += 50; // Virar dama é muito valioso
                } else if (!piece.isKing && move.moveData.row < 2) {
                    score += 20; // Perto de virar dama
                }
                
                // Controle do centro
                const centerDistance = Math.abs(move.moveData.col - 3.5) + Math.abs(move.moveData.row - 3.5);
                score += (8 - centerDistance) * 3;
                
                // Segurança (evitar capturas no próximo movimento)
                if (this.isPositionSafe(move.moveData.row, move.moveData.col, 'black')) {
                    score += 10;
                } else {
                    score -= 20;
                }
                
                // Mobilidade (quantos movimentos possíveis após este movimento)
                score += this.getMobilityScore(move) * 2;
                
                return score;
            }
            
            simulateAdditionalCaptures(capture) {
                // Simular quantas capturas adicionais serão possíveis
                const tempBoard = this.board.map(row => [...row]);
                
                // Aplicar captura temporariamente
                const piece = tempBoard[capture.fromRow][capture.fromCol];
                tempBoard[capture.moveData.row][capture.moveData.col] = piece;
                tempBoard[capture.fromRow][capture.fromCol] = null;
                tempBoard[capture.moveData.capturedRow][capture.moveData.capturedCol] = null;
                
                // Contar capturas adicionais possíveis
                let additionalCaptures = 0;
                const captureDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                
                captureDirections.forEach(([deltaRow, deltaCol]) => {
                    const jumpRow = capture.moveData.row + deltaRow;
                    const jumpCol = capture.moveData.col + deltaCol;
                    const landRow = capture.moveData.row + (deltaRow * 2);
                    const landCol = capture.moveData.col + (deltaCol * 2);
                    
                    if (this.isValidPosition(jumpRow, jumpCol) && 
                        this.isValidPosition(landRow, landCol) &&
                        tempBoard[jumpRow][jumpCol] && 
                        tempBoard[jumpRow][jumpCol].color === 'red' &&
                        !tempBoard[landRow][landCol]) {
                        additionalCaptures++;
                    }
                });
                
                return additionalCaptures;
            }
            
            isPositionSafe(row, col, color) {
                // Verificar se posição está segura de capturas
                const captureDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                
                for (let [deltaRow, deltaCol] of captureDirections) {
                    const threatRow = row - deltaRow;
                    const threatCol = col - deltaCol;
                    const escapeRow = row + deltaRow;
                    const escapeCol = col + deltaCol;
                    
                    if (this.isValidPosition(threatRow, threatCol) && 
                        this.isValidPosition(escapeRow, escapeCol) &&
                        this.board[threatRow][threatCol] && 
                        this.board[threatRow][threatCol].color !== color &&
                        !this.board[escapeRow][escapeCol]) {
                        return false; // Posição não é segura
                    }
                }
                
                return true;
            }
            
            getMobilityScore(move) {
                // Contar quantos movimentos serão possíveis após este movimento
                const piece = this.board[move.fromRow][move.fromCol];
                const directions = piece.isKing 
                    ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
                    : [[1, -1], [1, 1]]; // IA sempre move para baixo
                
                let mobilityCount = 0;
                
                directions.forEach(([deltaRow, deltaCol]) => {
                    const newRow = move.moveData.row + deltaRow;
                    const newCol = move.moveData.col + deltaCol;
                    
                    if (this.isValidPosition(newRow, newCol) && !this.board[newRow][newCol]) {
                        mobilityCount++;
                    }
                });
                
                return mobilityCount;
            }
            
            getAllPossibleMoves(color) {
                const allMoves = [];
                
                for (let row = 0; row < this.BOARD_SIZE; row++) {
                    for (let col = 0; col < this.BOARD_SIZE; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === color) {
                            const moves = this.getPossibleMoves(row, col);
                            moves.forEach(moveData => {
                                allMoves.push({ fromRow: row, fromCol: col, moveData });
                            });
                        }
                    }
                }
                
                // Se há capturas disponíveis, retornar APENAS as capturas
                const captures = allMoves.filter(move => move.moveData.type === 'capture');
                if (captures.length > 0) {
                    return captures;
                }
                
                return allMoves;
            }
            
            checkGameOver() {
                if (this.redPieces === 0) {
                    this.endGame('black');
                } else if (this.blackPieces === 0) {
                    this.endGame('red');
                } else {
                    // Verificar se jogador atual tem movimentos
                    const moves = this.getAllPossibleMoves(this.currentPlayer);
                    if (moves.length === 0) {
                        this.endGame(this.currentPlayer === 'red' ? 'black' : 'red');
                    }
                }
            }
            
            endGame(winner) {
                this.gameOver = true;
                this.winner = winner;
                
                setTimeout(() => {
                    const modal = document.getElementById('game-over-modal');
                    const result = document.getElementById('game-result');
                    
                    if (winner === 'red') {
                        result.textContent = '🎉 Você Venceu!';
                        result.className = 'text-2xl font-bold mb-4 text-green-600';
                    } else {
                        result.textContent = '🤖 IA Venceu!';
                        result.className = 'text-2xl font-bold mb-4 text-red-600';
                    }
                    
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                }, 1000);
            }
            
            updateBoardDisplay() {
                const squares = document.querySelectorAll('[data-row][data-col]');
                
                squares.forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    
                    // Remover classes anteriores
                    square.classList.remove('valid-move', 'capture-move');
                    
                    // Destacar movimentos válidos
                    const validMove = this.validMoves.find(move => move.row === row && move.col === col);
                    if (validMove) {
                        if (validMove.type === 'capture') {
                            square.classList.add('capture-move');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }
                    
                    // Atualizar peças
                    const piece = this.board[row][col];
                    square.innerHTML = '';
                    
                    if (piece) {
                        const pieceElement = this.createPieceElement(piece);
                        
                        // Destacar peça selecionada
                        if (this.selectedPiece && 
                            this.selectedPiece.row === row && 
                            this.selectedPiece.col === col) {
                            pieceElement.classList.add('selected');
                        }
                        
                        square.appendChild(pieceElement);
                    }
                });
            }
            
            updateDisplay() {
                document.getElementById('red-count').textContent = this.redPieces;
                document.getElementById('black-count').textContent = this.blackPieces;
                
                if (!this.gameOver) {
                    const status = this.currentPlayer === 'red' ? 'Sua vez!' : 'Vez da IA';
                    document.getElementById('game-status').textContent = status;
                }
                
                this.createBoardHTML();
            }
            
            attachEventListeners() {
                // Novo Jogo
                document.getElementById('new-game').addEventListener('click', () => {
                    this.resetGame();
                });
                
                // Alternar modo
                document.getElementById('toggle-mode').addEventListener('click', () => {
                    this.vsComputer = !this.vsComputer;
                    document.getElementById('toggle-mode').textContent = 
                        this.vsComputer ? '🤖 vs COMPUTADOR' : '👥 vs HUMANO';
                    this.resetGame();
                });
                
                // Alternar dificuldade
                document.getElementById('difficulty-btn').addEventListener('click', () => {
                    const difficulties = ['easy', 'medium', 'hard'];
                    const currentIndex = difficulties.indexOf(this.difficulty);
                    this.difficulty = difficulties[(currentIndex + 1) % difficulties.length];
                    
                    const difficultyTexts = {
                        easy: '😊 FÁCIL',
                        medium: '🤔 MÉDIO',
                        hard: '🔥 DIFÍCIL'
                    };
                    
                    const difficultyColors = {
                        easy: 'bg-green-500 hover:bg-green-600',
                        medium: 'bg-green-700 hover:bg-green-800',
                        hard: 'bg-green-900 hover:bg-green-950'
                    };
                    
                    const btn = document.getElementById('difficulty-btn');
                    btn.textContent = difficultyTexts[this.difficulty];
                    
                    // Remover classes antigas e adicionar novas
                    btn.className = `text-white px-4 py-2 rounded-lg font-bold transition-colors flex-1 ${difficultyColors[this.difficulty]}`;
                });
                
                // Modal de regras
                document.getElementById('rules-btn').addEventListener('click', () => {
                    document.getElementById('rules-modal').classList.remove('hidden');
                    document.getElementById('rules-modal').classList.add('flex');
                });
                
                document.getElementById('close-rules').addEventListener('click', () => {
                    document.getElementById('rules-modal').classList.add('hidden');
                    document.getElementById('rules-modal').classList.remove('flex');
                });
                
                document.getElementById('close-rules-btn').addEventListener('click', () => {
                    document.getElementById('rules-modal').classList.add('hidden');
                    document.getElementById('rules-modal').classList.remove('flex');
                });
                
                // Modal game over
                document.getElementById('play-again').addEventListener('click', () => {
                    document.getElementById('game-over-modal').classList.add('hidden');
                    document.getElementById('game-over-modal').classList.remove('flex');
                    this.resetGame();
                });
                
                document.getElementById('back-menu').addEventListener('click', () => {
                    window.location.href = '../index.html';
                });
            }
            
            resetGame() {
                this.gameOver = false;
                this.winner = null;
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.validMoves = [];
                this.redPieces = 12;
                this.blackPieces = 12;
                this.isComputerThinking = false;
                
                this.initializeBoard();
                this.updateDisplay();
                this.updateDifficultyButton(); // Atualizar cor do botão
                
                // Fechar modais
                document.getElementById('game-over-modal').classList.add('hidden');
                document.getElementById('rules-modal').classList.add('hidden');
            }
            
            updateDifficultyButton() {
                const difficultyTexts = {
                    easy: '😊 FÁCIL',
                    medium: '🤔 MÉDIO',
                    hard: '🔥 DIFÍCIL'
                };
                
                const difficultyColors = {
                    easy: 'bg-green-500 hover:bg-green-600',
                    medium: 'bg-green-700 hover:bg-green-800',
                    hard: 'bg-green-900 hover:bg-green-950'
                };
                
                const btn = document.getElementById('difficulty-btn');
                btn.textContent = difficultyTexts[this.difficulty];
                btn.className = `text-white px-4 py-2 rounded-lg font-bold transition-colors flex-1 ${difficultyColors[this.difficulty]}`;
            }
        }
        
        // Inicializar jogo
        document.addEventListener('DOMContentLoaded', () => {
            new CheckersGame();
        });
    </script>
</body>
</html>
